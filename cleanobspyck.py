#!/usr/bin/env python
# -*- coding: utf-8 -*-
#-------------------------------------------------------------------
__version__="0.0.1"
COMPANY_NAME = 'GIN'
APP_NAME = 'cleanpyck'
#---------------------------------------------------------------------

import os
import sys
import argparse
import copy

from PyQt4 import QtGui, QtCore
from PyQt4.QtCore import QEvent, Qt
from PyQt4.QtCore import QVariant, QString, QSize

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm
import matplotlib.transforms
#from matplotlib.patches import Ellipse
from matplotlib.ticker import FuncFormatter, FormatStrFormatter, MaxNLocator
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as QNavigationToolbar
from matplotlib.backend_bases import MouseEvent as MplMouseEvent, KeyEvent as MplKeyEvent

import warnings
with warnings.catch_warnings(record=True) as w:
    from obspy.core import UTCDateTime, Stream, Trace

from qt_design_short import Ui_qMainWindow_obsPyck

from util import *


class ObsPyck(QtGui.QMainWindow):
    """
    Main Window with the design loaded from the Qt Designer.
    """
    def __init__(self, T0, T1, dicts, streams, options, keys):
        """
        Standard init.
        """
        self.load_data(dicts, streams, options, keys)
        # T0 is the global reference time (zero in relative time scales)
        self.T0 = T0
        self.T0 += options.starttime_offset
        # T1 is the max end time
        self.T1 = T1 + 10
        print "T0 =", self.T0, "T1 =", self.T1
        # init the GUI stuff
        QtGui.QMainWindow.__init__(self)
        # Init the widgets from the autogenerated file.
        # All GUI elements will be accessible via self.widgets.name_of_element
        self.widgets = Ui_qMainWindow_obsPyck()
        self.widgets.setupUi(self)
        # Create little color icons in front of the phase type combo box.
        # Needs to be done pretty much at the beginning because some other
        # stuff relies on the phase type being set.
        pixmap = QtGui.QPixmap(70, 50)
        for phase_type in list(SEISMIC_PHASES):
            rgb = matplotlib_color_to_rgb(PHASE_COLORS[phase_type])
            pixmap.fill(QtGui.QColor(*rgb))
            icon = QtGui.QIcon(pixmap)
            self.widgets.qComboBox_phaseType.addItem(icon, phase_type)
        self.qMain = self.widgets.centralwidget
        # Add write methods to stdout/stderr text edits in GUI displays to
        # enable redirections for stdout and stderr.
        # we need to remember the original handles because we only write on the
        # console during debug modus.
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        # We automatically redirect all messages to both console and Gui boxes
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)
        # Matplotlib figure.
        # we bind the figure to the FigureCanvas, so that it will be
        # drawn using the specific backend graphic functions
        self.canv = self.widgets.qMplCanvas
        # We have to reset all splitters such that the widget with the canvas
        # in it can not be collapsed as this leads to a crash of the program
        _i = self.widgets.qSplitter_vertical.indexOf(self.widgets.qSplitter_horizontal)
        self.widgets.qSplitter_vertical.setCollapsible(_i, False)
        _i = self.widgets.qSplitter_horizontal.indexOf(self.widgets.qWidget_mpl)
        self.widgets.qSplitter_horizontal.setCollapsible(_i, False)
        # XXX this resizing operation (buttons minimum size) should be done in
        # XXX the qt_designer.ui but I didn't find the correct settings there..
        self.widgets.qSplitter_horizontal.setSizes([1, 9999])
        # Bind the canvas to the mouse wheel event. Use Qt events for it
        # because the matplotlib events seem to have a problem with Debian.
        self.widgets.qMplCanvas.wheelEvent = self.__mpl_wheelEvent
        #self.keyPressEvent = self.__mpl_keyPressEvent
        self.fig = self.widgets.qMplCanvas.fig
        facecolor = self.qMain.palette().color(QtGui.QPalette.Window).getRgb()
        self.fig.set_facecolor([value / 255.0 for value in facecolor])
        #Define some flags, dictionaries and plotting options
        #this next flag indicates if we zoom on time or amplitude axis
        self.flagWheelZoomAmplitude = False
        #check_keybinding_conflicts(KEYS)
        warn_msg, merge_msg = "", ""
        # exit if no streams are left after removing everything not suited.
        if not streams:
            raise Exception("No streams left to work with after removing bad streams.")
        # set up dictionaries to store phase_type/axes/line informations
        self.lines = {}
        self.texts = {}
        # sort streams by station name
        streams.sort(key=lambda st: st[0].stats['station'])
        # получить (если возможно) исходные времена вступлений для этих файлов
        #(streams, dicts) = setup_dicts(streams, options)
        #
        self.eventMapColors = []
        for i in xrange(len(dicts)):
            self.eventMapColors.append((0.,  1.,  0.,  1.))
        #Define a pointer to navigate through the streams
        self.stNum = len(streams)
        self.stPt = 0
        #
        self.drawAxes()
        self.multicursor = MultiCursor(self.canv, self.axs, useblit=True,
            color='k', linewidth=1, ls='dotted')
        # Initialize the stream related widgets with the right values:
        self.widgets.qComboBox_streamName.clear()
        labels = ["%s.%s" % (st[0].stats.network, st[0].stats.station) \
                  for st in self.streams]
        self.widgets.qComboBox_streamName.addItems(labels)
        # set the filter/trigger default values according to command line
        # options or optionparser default values
        self.updateStreamLabels()
        print >> sys.stderr, warn_msg
        # XXX mpl connect XXX XXX XXX XXX XXX
        # XXX http://eli.thegreenplace.net/files/prog_code/qt_mpl_bars.py.txt
        # XXX http://eli.thegreenplace.net/2009/01/20/matplotlib-with-pyqt-guis/
        # XXX https://www.packtpub.com/sites/default/files/sample_chapters/7900-matplotlib-for-python-developers-sample-chapter-6-embedding-matplotlib-in-qt-4.pdf
        # XXX mpl connect XXX XXX XXX XXX XXX
        # Activate all mouse/key/Cursor-events
        # XXX MAYBE rename the event handles again so that they DONT get
        # XXX autoconnected via Qt?!?!?
        self.canv.mpl_connect('key_press_event', self.__mpl_keyPressEvent)
        self.canv.mpl_connect('key_release_event', self.__mpl_keyReleaseEvent)
        self.canv.mpl_connect('button_release_event', self.__mpl_mouseButtonReleaseEvent)
        # The scroll event is handled using Qt.
        #self.canv.mpl_connect('scroll_event', self.__mpl_wheelEvent)
        self.canv.mpl_connect('button_press_event', self.__mpl_mouseButtonPressEvent)
        self.canv.mpl_connect('motion_notify_event', self.__mpl_motionNotifyEvent)
        self.multicursorReinit()
        self.canv.show()
        self.showMaximized()
        # XXX XXX the good old focus issue again!?! no events get to the mpl canvas
        # XXX self.canv.setFocusPolicy(Qt.WheelFocus)
        #print self.canv.hasFocus()
        self.settings = QtCore.QSettings(COMPANY_NAME, APP_NAME)
        #self.setWindowTitle('pyck (v. %s)' % __version__)
        size = self.settings.value("MainWindow/Size", QVariant(QSize(800, 600))).toSize()
        self.resize(size)
        #
        # connect own button and menu clicks
        #self.connect(self.widgets.exit_action, QtCore.SIGNAL("triggered()"), self.close)
        #self.connect(self.widgets.open_action, QtCore.SIGNAL("triggered()"), self.open_file)
        # click on button box (OK, cancel)
        self.connect(self.widgets.buttonBox, QtCore.SIGNAL("accepted()"), self.ok_save)
        self.connect(self.widgets.buttonBox, QtCore.SIGNAL("rejected()"), self.cancel_save)
    
    def load_data(self, dicts, streams, options, keys, redraw=False):
        """ загрузить новые данные """
        self.dicts = dicts
        self.dicts_original = copy.deepcopy(dicts)
        self.streams = streams
        self.options = options
        self.keys = keys
        # initialization again
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.dictEvent = {}
        #
        # set up dictionaries to store phase_type/axes/line informations
        self.lines = {}
        self.texts = {}
        # sort streams by station name
        streams.sort(key=lambda st: st[0].stats['station'])
        self.eventMapColors = []
        for i in xrange(len(dicts)):
            self.eventMapColors.append((0.,  1.,  0.,  1.))
        #Define a pointer to navigate through the streams
        self.stNum = len(streams)
        self.stPt = 0
        #
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.dictEvent = {}
        # redraws
        if redraw:
            self.drawAxes()
            self.redraw()
            self.canv.draw()
    
    def open_file(self):
        """ открытие одиночного файла """
        filename = QtGui.QFileDialog.getOpenFileName(self, 'Open file',
            '/home/Work/seis')
        print filename
        stream = read(str(filename))
        self.load_data(self.dicts, [stream], self.options, self.keys, redraw=True)

    def ok_save(self):
        """ Сохранение внесённых изменений """
        print("*"*30)
        print("saving changes here...")
        #

    def cancel_save(self):
        """ отмена внесённых изменений во времена вступлений """
        print("*"*30)
        print("cancel changes...")
        self.dicts = copy.deepcopy(self.dicts_original)
        self.updateAllItems()
        self.redraw()

    #===

    def time_abs2rel(self, abstime):
        """
        Converts an absolute UTCDateTime to the time in ObsPyck's relative time
        frame.
        """
        return abstime - self.T0

    def time_rel2abs(self, reltime):
        """
        Converts a relative time in global relative time system to the absolute
        UTCDateTime.
        """
        return self.T0 + reltime
    
    def cleanup(self):
        pass

    ###########################################################################
    ### signal handlers START #################################################
    ###########################################################################

    def on_qToolButton_overview_toggled(self):
        state = self.widgets.qToolButton_overview.isChecked()
        widgets_leave_active = ("qToolButton_overview",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawStreamOverview()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delAxes()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_clearAll_clicked(self, *args):
        # Workaround for overloaded signals:
        #  - "clicked" signal get emitted once without *args and once with an
        #    int as additional argument
        #  - we have to be flexible in the call, otherwise we get errors
        #  - we have to catch one signal, otherwise the action gets performed
        #    twice
        if args:
            return
        self.clearDictionaries()
        self.updateAllItems()
        self.redraw()


    def on_qToolButton_debug_clicked(self, *args):
        if args:
            return
        try:
            self.debug()
        except BaseException, e:
            print(e)
    
    def on_qToolButton_previousStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt - 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_streamName_currentIndexChanged(self, newvalue):
        self.stPt = self.widgets.qComboBox_streamName.currentIndex()
        xmin, xmax = self.axs[0].get_xlim()
        self.delAllItems()
        self.delAxes()
        self.fig.clear()
        self.drawAxes()
        self.drawAllItems()
        self.multicursorReinit()
        self.axs[0].set_xlim(xmin, xmax)
        self.updatePlot()
        stats = self.streams[self.stPt][0].stats
        print "Going to stream: %s.%s" % (stats.network, stats.station)
        self.updateStreamNumberLabel()

    def on_qToolButton_nextStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt + 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_phaseType_currentIndexChanged(self, newvalue):
        # XXX: Ugly hack because it can be called before the combo box has any
        # entries.
        try:
            self.updateMulticursorColor()
            self.redraw()
        except AttributeError:
            pass

    def on_qToolButton_filter_toggled(self):
        self.updatePlot()


    def on_qToolButton_arpicker_clicked(self, *args):
        """
        Set automatic P/S picks using the AR picker.
        """
        if args:
            return
        self.clearDictionaries()
        self.updateAllItems()
        self._arpicker()
        self.updateAllItems()
        self.redraw()


    def debug(self):
        sys.stdout = self.stdout_backup
        sys.stderr = self.stderr_backup
        ## DEBUG PYQT START
        QtCore.pyqtRemoveInputHook()
        try:
            import ipdb
            ipdb.set_trace()
        except ImportError:
            import pdb
            pdb.set_trace()
        QtCore.pyqtRestoreInputHook()
        ## DEBUG PYQT END
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)

    def setFocusToMatplotlib(self):
        self.canv.setFocus() # XXX needed??

    def drawLine(self, key):
        """
        Draw a line for pick of given key in all axes of the current stream.
        Stores the line in a dict to be able to remove the line later on.

        self.Lines contains dict for each phase type (e.g. "P").
        self.Lines[phase_type] is a dict mapping axes objects to line objects.
        e.g.: self.Lines["P"][<matplotlib.axes.AxesSubplot object at 0x...>]
              would return the line object for the P phase in the given axes.
        """
        if key in self.lines:
            self.delLine(key)
        d = self.dicts[self.stPt]
        if key not in d:
            return
        self.lines[key] = {}
        ymin = 1.0 - PHASE_LINEHEIGHT_PERC[key]
        ymax = PHASE_LINEHEIGHT_PERC[key]
        # draw lines and store references in dictionary
        for ax in self.axs:
            line = ax.axvline(d[key], color=PHASE_COLORS[key],
                    linewidth=AXVLINEWIDTH, linestyle=PHASE_LINESTYLES[key],
                    ymin=ymin, ymax=ymax)
            self.lines[key][ax] = line
    
    def delLine(self, key):
        """
        Delete all lines for pick of given key in all axes of the current
        stream.
        
        See drawLine().
        """
        if key not in self.lines:
            return
        for ax, line in self.lines[key].iteritems():
            ax.lines.remove(line)
        del self.lines[key]

    def updateLine(self, key):
        self.delLine(key)
        self.drawLine(key)
    
    def drawLabel(self, key):
        """
        Draws Labels at pick axvlines.
        Currently expects as keys either "P" or "S".
        """
        # delegate drawing of synthetic picks, this is different...
        if 'synth' in key:
            return self.drawSynthLabel(key)
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        label = key + ':'
        # try to recognize and map the onset string to a character
        key_onset = key + 'Onset'
        if key_onset in dict:
            label += ONSET_CHARS.get(dict[key_onset].lower(), "?")
        else:
            label += '_'
        # try to recognize and map the polarity string to a character
        key_pol = key + 'Pol'
        if key_pol in dict:
            label += POLARITY_CHARS.get(dict[key_pol].lower(), "?")
        else:
            label += '_'
        key_weight = key + 'Weight'
        if key_weight in dict:
            label += str(dict[key_weight])
        else:
            label += '_'
        ax = self.axs[0]
        # draw text and store references in dictionary
        self.texts[key] = {}
        text = ax.text(dict[key], 1 - 0.01 * len(self.axs), '  ' + label,
                transform=self.trans[0], color=PHASE_COLORS[key],
                family='monospace', va="top")
        self.texts[key][ax] = text

    def drawSynthLabel(self, key):
        """
        Draw the label for a synthetic pick. This is a bit different from
        the other labels.
        """
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        key_res = key[0] + "res"
        label = '%s: %+.3fs' % (key, dict[key_res])
        ax = self.axs[0]
        # draw text and store references in dictionary
        self.texts[key] = {}
        text = ax.text(dict[key], 1 - 0.03 * len(self.axs), '  ' + label,
                transform=self.trans[0], color=PHASE_COLORS[key],
                family='monospace', va="top")
        self.texts[key][ax] = text
    
    def delLabel(self, key):
        """
        Delete label for pick of given key in the current stream.
        
        See drawLabel().
        """
        if key not in self.texts:
            return
        for ax, text in self.texts[key].iteritems():
            ax.texts.remove(text)
        del self.texts[key]

    def updateLabel(self, key):
        self.delLabel(key)
        self.drawLabel(key)

    def drawIds(self):
        """
        draws the trace ids plotted as text into each axes.
        """
        # make a Stream with the traces that are plotted
        if self.widgets.qToolButton_overview.isChecked():
            tmp_stream = Stream([st.select(component="Z")[0] for st in self.streams])
        else:
            tmp_stream = self.streams[self.stPt]
        for ax, tr in zip(self.axs, tmp_stream):
            ax.text(0.01, 0.95, tr.id, va="top", ha="left", fontsize=18,
                    family='monospace', color="blue", zorder=10000,
                    transform=ax.transAxes)

    def updateIds(self, textcolor):
        """
        updates the trace ids plotted as text into each axes.
        if "rotate" button is on map the component key to LQT or ZRT.
        CAUTION: The last letter of the ID plotted here is used to identify
                 the component when setting S polarities!!
                 Change with caution!!
        """
        # make a Stream with the traces that are plotted
        # if in overview mode this is not one of the original streams but a
        # stream with all the Z traces of all streams
        tmp_stream = self.streams[self.stPt]
        for ax, tr in zip(self.axs, tmp_stream):
            tr_id = tr.id
            # if trigger button is on: add to trace ids
            # trace ids are first text-plot so its at position 0
            t = ax.texts[0]
            t.set_text(tr_id)
            t.set_color(textcolor)

    def drawMagMarker(self, key):
        """
        Draw a magnitude marker for pick of given key in the current stream.
        Stores the line in a dict to be able to remove the line later on.
        See drawLine() for details.

        Currently we expect either MagMin1, MagMax1, MagMin2 or MagMax2 so
        we estimate the axes we plot into by the last character of the key.
        Furthermore, we expect another key to exist that is key+"T" (e.g.
        MagMin1T for MagMin1) with the time information.
        """
        if key in self.lines:
            self.delLine(key)
        d = self.dicts[self.stPt]
        if key not in d: # or len(self.axs) < 2
            return
        ax_num = int(key[-1])
        ax = self.axs[ax_num]
        # we have to force the graph to the old axes limits because of the
        # completely new line object creation
        xlims = list(ax.get_xlim())
        ylims = list(ax.get_ylim())
        keyT = key + "T"
        self.lines[key] = {}
        line = ax.plot((d[keyT],), (d[key],), markersize=MAG_MARKER['size'],
                markeredgewidth=MAG_MARKER['edgewidth'],
                color=PHASE_COLORS['Mag'], marker=MAG_MARKER['marker'],
                zorder=2000)[0]
        self.lines[key][ax] = line
        ax.set_xlim(xlims)
        ax.set_ylim(ylims)

    def delMagMarker(self, key):
        self.delLine(key)
    
    def updateMagMarker(self, key):
        self.delMagMarker(key)
        self.drawMagMarker(key)
    
    def delKey(self, key):
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        del dict[key]
        print "%s deleted." % KEY_FULLNAMES[key]
        # we have to take care of some special cases:
        if key == 'S':
            if 'Saxind' in dict:
                del dict['Saxind']
        elif key in ['MagMin1', 'MagMax1', 'MagMin2', 'MagMax2']:
            key2 = key + 'T'
            del dict[key2]
    
    def drawAxes(self):
        st = self.streams[self.stPt]
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        self.t = t
        for i, tr in enumerate(st):
            if i == 0:
                ax = fig.add_subplot(len(st), 1, 1)
            else:
                ax = fig.add_subplot(len(st), 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax) 
            # relative x-axis times start with 0 at global reference time
            starttime_relative = self.time_abs2rel(tr.stats.starttime)
            sampletimes = np.arange(starttime_relative,
                    starttime_relative + (tr.stats.delta * tr.stats.npts),
                    tr.stats.delta)
            # XXX sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData,
                                                                         ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            # normalize with overall sensitivity and convert to nm/s
            # if not explicitly deactivated on command line
            plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
            textcolor = "blue"
        self.drawIds()
        axs[-1].xaxis.set_ticks_position("both")
        label = self.T0.isoformat().replace("T", "  ")
        self.supTit = fig.suptitle(label, ha="left", va="bottom",
                                   x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)
    
    def delAxes(self):
        for ax in self.axs:
            if ax in self.fig.axes: 
                self.fig.delaxes(ax)
            del ax
        if self.supTit in self.fig.texts:
            self.fig.texts.remove(self.supTit)
    
    def redraw(self):
        for line in self.multicursor.lines:
            line.set_visible(False)
        self.canv.draw()
    
    def updatePlot(self):
        """
        Update plot either with raw data or filter data and use filtered data.
        Depending on status of "Filter" Button. Also check "Rotate" buttons if
        data should be rotated to LQT or ZRT coordinates.
        """
        # XXX copying is only necessary if "Filter" or "Rotate" is selected
        # XXX it is simpler for teh code to just copy in any case..
        st = self.streams[self.stPt].copy()
        d = self.dicts[self.stPt]
        self.updateIds("blue")
        self.redraw()
            
        # Update all plots' y data
        for tr, plot in zip(st, self.plts):
            plot.set_ydata(tr.data)
        self.redraw()

    # Define the event that handles the setting of P- and S-wave picks
    # XXX prefix with underscores to avoid autoconnect to Qt
    def __mpl_keyPressEvent(self, ev):
        keys = self.keys
        phase_type = str(self.widgets.qComboBox_phaseType.currentText())
        dict = self.dicts[self.stPt]
        st = self.streams[self.stPt]
        tr = st[self.axs.index(ev.inaxes)]
        
        #######################################################################
        # Start of key events related to picking                              #
        #######################################################################
        # For some key events (picking events) we need information on the x/y
        # position of the cursor:
        if ev.key in [keys['setPick'], keys['setPickError'],
                      keys['setMagMin'], keys['setMagMax']]:
            # some keyPress events only make sense inside our matplotlib axes
            if ev.inaxes not in self.axs:
                return
            # get the correct sample times array for the click
            t = self.t[self.axs.index(ev.inaxes)]
            # We want to round from the picking location to
            # the time value of the nearest sample:
            samp_rate = st[0].stats.sampling_rate
            pickSample = (ev.xdata - t[0]) * samp_rate
            print pickSample
            pickSample = round(pickSample)
            print pickSample
            # we need the position of the cursor location
            # in the seismogram array:
            xpos = pickSample
            # Determine the time of the nearest sample
            pickSample = t[pickSample]
            print pickSample
            print ev.inaxes.lines[0].get_ydata()[xpos]

        if ev.key == keys['setPick']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs:
                return
            if phase_type in SEISMIC_PHASES:
                dict[phase_type] = pickSample
                if phase_type == "S":
                    dict['Saxind'] = self.axs.index(ev.inaxes)
                depending_keys = (phase_type + k for k in ['', 'synth'])
                for key in depending_keys:
                    self.updateLine(key)
                    self.updateLabel(key)
                #check if the new P pick lies outside of the Error Picks
                key1 = phase_type + "Err1"
                key2 = phase_type + "Err2"
                if key1 in dict and dict[phase_type] < dict[key1]:
                    self.delLine(key1)
                    self.delKey(key1)
                if key2 in dict and dict[phase_type] > dict[key2]:
                    self.delLine(key2)
                    self.delKey(key2)
                self.redraw()
                abs_time = self.time_rel2abs(dict[phase_type])
                print "%s set at %.3f (%s)" % (KEY_FULLNAMES[phase_type],
                    dict[phase_type], abs_time.isoformat())
                return

        if ev.key in keys['setWeight'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Weight"
                dict[key] = keys['setWeight'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %i" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setPol'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Pol"
                dict[key] = keys['setPol'][ev.key]
                # map SH/SV polarities if rotated to ZRT
                if phase_type == "S":
                    try:
                        comp = ev.inaxes.texts[0].get_text()[-1].upper()
                        dict[key] = S_POL_MAP_ZRT[comp][dict[key]]
                        print "setting polarity for %s" % S_POL_PHASE_TYPE[comp]
                    except:
                        err = "Warning: to map up/down polarity to SH/SV " + \
                              "equivalents rotate to ZRT and place mouse " + \
                              "over R or T axes."
                        print >> sys.stderr, err
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setOnset'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Onset"
                dict[key] = keys['setOnset'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key == keys['delPick']:
            if phase_type in SEISMIC_PHASES:
                depending_keys = (phase_type + k for k in ['', 'Err1', 'Err2'])
                for key in depending_keys:
                    self.delLine(key)
                depending_keys = (phase_type + k for k in ['', 'Weight', 'Pol', 'Onset', 'Err1', 'Err2'])
                for key in depending_keys:
                    self.delKey(key)
                self.delLabel(phase_type)
                self.redraw()
                return

        if ev.key == keys['setPickError']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs:
                return
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                # Determine if left or right Error Pick
                if pickSample < dict[phase_type]:
                    key = phase_type + 'Err1'
                elif pickSample > dict[phase_type]:
                    key = phase_type + 'Err2'
                dict[key] = pickSample
                self.updateLine(key)
                self.redraw()
                abs_time = self.time_rel2abs(dict[key])
                print "%s set at %.3f (%s)" % (KEY_FULLNAMES[key],
                                               dict[key], abs_time.isoformat())
                return

        if ev.key == keys['setMagMin']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs[1:3]:
                return
            if phase_type == 'Mag':
                if len(self.axs) < 2:
                    err = "Error: Magnitude picking only supported with a " + \
                          "minimum of 2 axes."
                    print >> sys.stderr, err
                    return
                # determine which dict keys to work with
                key = 'MagMin'
                key_other = 'MagMax'
                if ev.inaxes is self.axs[1]:
                    key += '1'
                    key_other += '1'
                elif ev.inaxes is self.axs[2]:
                    key += '2'
                    key_other += '2'
                keyT = key + 'T'
                keyT_other = key_other + 'T'
                # do the actual work
                ydata = ev.inaxes.lines[0].get_ydata() #get the first line hoping that it is the seismogram!
                cutoffSamples = xpos - MAG_PICKWINDOW #remember, how much samples there are before our small window! We have to add this number for our MagMinT estimation!
                dict[key] = np.min(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                # special handling for GSE2 data: apply calibration
                if tr.stats._format == "GSE2":
                    dict[key] = dict[key] / (tr.stats.calib * 2 * np.pi / tr.stats.gse2.calper)
                # save time of magnitude minimum in seconds
                tmp_magtime = cutoffSamples + np.argmin(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                tmp_magtime = tmp_magtime / samp_rate
                dict[keyT] = tmp_magtime
                #delete old MagMax Pick, if new MagMin Pick is higher
                if key_other in dict and dict[key] > dict[key_other]:
                    self.delMagMarker(key_other)
                    self.delKey(key_other)
                    self.delKey(keyT_other)
                self.updateMagMarker(key)
                self.redraw()
                print "%s set: %s at %.3f" % (KEY_FULLNAMES[key], dict[key],
                                              dict[keyT])
                return

        if ev.key == keys['setMagMax']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs[1:3]:
                return
            if phase_type == 'Mag':
                if len(self.axs) < 2:
                    err = "Error: Magnitude picking only supported with a " + \
                          "minimum of 2 axes."
                    print >> sys.stderr, err
                    return
                # determine which dict keys to work with
                key = 'MagMax'
                key_other = 'MagMin'
                if ev.inaxes is self.axs[1]:
                    key += '1'
                    key_other += '1'
                elif ev.inaxes is self.axs[2]:
                    key += '2'
                    key_other += '2'
                keyT = key + 'T'
                keyT_other = key_other + 'T'
                # do the actual work
                ydata = ev.inaxes.lines[0].get_ydata() #get the first line hoping that it is the seismogram!
                cutoffSamples = xpos - MAG_PICKWINDOW #remember, how much samples there are before our small window! We have to add this number for our MagMaxT estimation!
                dict[key] = np.max(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                # special handling for GSE2 data: apply calibration
                if tr.stats._format == "GSE2":
                    dict[key] = dict[key] / (tr.stats.calib * 2 * np.pi / tr.stats.gse2.calper)
                # save time of magnitude maximum in seconds
                tmp_magtime = cutoffSamples + np.argmax(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                tmp_magtime = tmp_magtime / samp_rate
                dict[keyT] = tmp_magtime
                #delete old MagMin Pick, if new MagMax Pick is lower
                if key_other in dict and dict[key] < dict[key_other]:
                    self.delMagMarker(key_other)
                    self.delKey(key_other)
                    self.delKey(keyT_other)
                self.updateMagMarker(key)
                self.redraw()
                print "%s set: %s at %.3f" % (KEY_FULLNAMES[key], dict[key],
                                              dict[keyT])
                return

        if ev.key == keys['delMagMinMax']:
            if phase_type == 'Mag':
                if ev.inaxes is self.axs[1]:
                    for key in ['MagMin1', 'MagMax1']:
                        self.delMagMarker(key)
                        self.delKey(key)
                elif ev.inaxes is self.axs[2]:
                    for key in ['MagMin2', 'MagMax2']:
                        self.delMagMarker(key)
                        self.delKey(key)
                else:
                    return
                self.redraw()
                return
        #######################################################################
        # End of key events related to picking                                #
        #######################################################################
        
        if ev.key == keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = True

        # iterate the phase type combobox
        if ev.key == keys['switchPhase']:
            combobox = self.widgets.qComboBox_phaseType
            next = (combobox.currentIndex() + 1) % combobox.count()
            combobox.setCurrentIndex(next)
            print "Switching Phase button"
            return
            
        if ev.key == keys['prevStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_previousStream_clicked()
            return

        if ev.key == keys['nextStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_nextStream_clicked()
            return
    
    def __mpl_keyReleaseEvent(self, ev):
        if ev.key == self.keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = False

    # Define zooming for the mouse wheel wheel
    def __mpl_wheelEvent(self, ev):
        # create mpl event from QEvent to get cursor position in data coords
        x = ev.x()
        y = self.canv.height() - ev.y()
        mpl_ev = MplMouseEvent("scroll_event", self.canv, x, y, "up", guiEvent=ev)
        # Calculate and set new axes boundaries from old ones
        #if self.widgets.qToolButton_showMap.isChecked():
        #    ax = self.axEventMap
        #else:
        ax = self.axs[0]
        (left, right) = ax.get_xbound()
        (bottom, top) = ax.get_ybound()
        # Get the keyboard modifiers. They are a enum type.
        # Use bitwise or to compare...hope this is correct.
        if ev.modifiers() == QtCore.Qt.NoModifier:
            # Zoom in.
            if ev.delta() < 0:
                left -= (mpl_ev.xdata - left) / 2
                right += (right - mpl_ev.xdata) / 2
                #if self.widgets.qToolButton_showMap.isChecked():
                #    top -= (mpl_ev.ydata - top) / 2
                #    bottom += (bottom - mpl_ev.ydata) / 2
            # Zoom out.
            elif ev.delta() > 0:
                left += (mpl_ev.xdata - left) / 2
                right -= (right - mpl_ev.xdata) / 2
                #if self.widgets.qToolButton_showMap.isChecked():
                #    top += (mpl_ev.ydata - top) / 2
                #    bottom -= (bottom - mpl_ev.ydata) / 2
        # Still able to use the dictionary.
        elif ev.modifiers() == getattr(QtCore.Qt,
                '%sModifier' % self.keys['switchWheelZoomAxis'].capitalize()):
            # Zoom in on wheel-up
            if ev.delta() < 0:
                top *= 2
                bottom *= 2
            # Zoom out on wheel-down
            elif ev.delta() > 0:
                top /= 2
                bottom /= 2
        ax.set_xbound(lower=left, upper=right)
        ax.set_ybound(lower=bottom, upper=top)
        self.redraw()
    
    # Define zoom reset for the mouse button 2 (always wheel wheel!?)
    def __mpl_mouseButtonPressEvent(self, ev):
        # set widgetlock when pressing mouse buttons and dont show cursor
        # cursor should not be plotted when making a zoom selection etc.
        if ev.button in [1, 3]:
            self.multicursor.visible = False
            # reuse this event as setPick / setPickError event
            if ev.button == 1:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPick']
                else:
                    ev.key = self.keys['setMagMin']
            elif ev.button == 3:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPickError']
                else:
                    ev.key = self.keys['setMagMax']
            self.__mpl_keyPressEvent(ev)
            # XXX self.canv.widgetlock(self.toolbar)
        # show traces from start to end
        # (Use Z trace limits as boundaries)
        elif ev.button == 2:
            #if self.widgets.qToolButton_showMap.isChecked():
            #    ax = self.axEventMap
            #else:
            ax = self.axs[0]
            ax.set_xbound(lower=self.xMin, upper=self.xMax)
            ax.set_ybound(lower=self.yMin, upper=self.yMax)
            # Update all subplots
            self.redraw()
            print "Resetting axes"
    
    def __mpl_mouseButtonReleaseEvent(self, ev):
        # release widgetlock when releasing mouse buttons
        if ev.button in [1, 3]:
            self.multicursor.visible = True
            # XXX self.canv.widgetlock.release(self.toolbar)

    def __mpl_motionNotifyEvent(self, ev):
        try:
            if ev.inaxes in self.axs:
                self.widgets.qLabel_xdata_rel.setText(formatXTicklabels(ev.xdata))
                label = self.time_rel2abs(ev.xdata).isoformat().replace("T", "  ")[:-3]
                self.widgets.qLabel_xdata_abs.setText(label)
                self.widgets.qLabel_ydata.setText("%.1f" % ev.ydata)
            else:
                self.widgets.qLabel_xdata_rel.setText("")
                self.widgets.qLabel_xdata_abs.setText(str(ev.xdata))
                self.widgets.qLabel_ydata.setText(str(ev.ydata))
        except TypeError:
            pass
    
    #lookup multicursor source: http://matplotlib.sourcearchive.com/documentation/0.98.1/widgets_8py-source.html
    def multicursorReinit(self):
        self.canv.mpl_disconnect(self.multicursor.id1)
        self.canv.mpl_disconnect(self.multicursor.id2)
        self.multicursor.__init__(self.canv, self.axs, useblit=True,
                                  color='black', linewidth=1, ls='dotted')
        self.updateMulticursorColor()
        # XXX self.canv.widgetlock.release(self.toolbar)

    def updateMulticursorColor(self):
        phase_name = str(self.widgets.qComboBox_phaseType.currentText())
        color = PHASE_COLORS[phase_name]
        for l in self.multicursor.lines:
            l.set_color(color)

    def updateStreamNumberLabel(self):
        label = "%02i/%02i" % (self.stPt + 1, self.stNum)
        self.widgets.qLabel_streamNumber.setText(label)
    
    def updateStreamNameCombobox(self):
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def updateStreamLabels(self):
        self.updateStreamNumberLabel()
        self.updateStreamNameCombobox()

    def catFile(self, file):
        lines = open(file, "rt").readlines()
        msg = ""
        for line in lines:
            msg += line
        print msg


    def drawStreamOverview(self):
        stNum = len(self.streams)
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        for i, st in enumerate(self.streams):
            tr = st.select(component="Z")[0]
            # make sure that the relative x-axis times start with 0 at the time
            # specified as start time on command line
            starttime_relative = self.time_abs2rel(tr.stats.starttime)
            sampletimes = np.arange(starttime_relative,
                    starttime_relative + (tr.stats.delta * tr.stats.npts),
                    tr.stats.delta)
            # sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            if i == 0:
                ax = fig.add_subplot(stNum, 1, i+1)
            else:
                ax = fig.add_subplot(stNum, 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData, ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            # we have to rotate first, because we have to copy the whole stream..
            tr = tr.copy()
            plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
        self.drawIds()
        axs[-1].xaxis.set_ticks_position("both")
        label = self.T0.isoformat().replace("T", "  ")
        self.supTit = fig.suptitle(label, ha="left", va="bottom", x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)

    def drawEventMap(self):
        dM = self.dictMagnitude
        dO = self.dictOrigin
        if dO == {}:
            err = "Error: No hypocenter data!"
            print >> sys.stderr, err
            return
        #XXX self.figEventMap.canvas.widgetlock.release(toolbar)
        #self.axEventMap = self.fig.add_subplot(111)
        bbox = matplotlib.transforms.Bbox.from_extents(0.08, 0.08, 0.92, 0.92)
        self.axEventMap = self.fig.add_axes(bbox, aspect='equal', adjustable='datalim')
        axEM = self.axEventMap
        #axEM.set_aspect('equal', adjustable="datalim")
        #self.fig.subplots_adjust(bottom=0.07, top=0.95, left=0.07, right=0.98)
        axEM.scatter([dO['Longitude']], [dO['Latitude']], 30,
                                color='red', marker='o')
        errLon, errLat = utlLonLat(dO['Longitude'], dO['Latitude'],
                                   dO['Longitude Error'], dO['Latitude Error'])
        errLon -= dO['Longitude']
        errLat -= dO['Latitude']
        ypos = 0.97
        xpos = 0.03
        axEM.text(xpos, ypos,
                  '%7.3f +/- %0.2fkm\n' % (dO['Longitude'], dO['Longitude Error']) + \
                  '%7.3f +/- %0.2fkm\n' % (dO['Latitude'], dO['Latitude Error']) + \
                  '  %.1fkm +/- %.1fkm' % (dO['Depth'], dO['Depth Error']),
                  va='top', ha='left', family='monospace', transform=axEM.transAxes)
        if 'Standarderror' in dO:
            axEM.text(xpos, ypos, "\n\n\n\n Residual: %.3f s" % \
                      dO['Standarderror'], va='top', ha='left',
                      color=PHASE_COLORS['P'], transform=axEM.transAxes,
                      family='monospace')
        if 'Magnitude' in dM and 'Uncertainty' in dM:
            self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % \
                               (dM['Magnitude'], dM['Uncertainty'])
            self.netMagText = axEM.text(xpos, ypos, self.netMagLabel, va='top',
                    ha='left', transform=axEM.transAxes,
                    color=PHASE_COLORS['Mag'], family='monospace')
        errorell = Ellipse(xy=[dO['Longitude'], dO['Latitude']],
                           width=errLon, height=errLat, angle=0, fill=False)
        axEM.add_artist(errorell)
        self.scatterMagIndices = []
        self.scatterMagLon = []
        self.scatterMagLat = []
        for i, dict in enumerate(self.dicts):
            # determine which stations are used in location, set color
            if any([ph + "res" in dict for ph in SEISMIC_PHASES]):
                stationColor = 'black'
            else:
                stationColor = 'gray'
            # plot stations at respective coordinates with names
            axEM.scatter((dict['StaLon'],), (dict['StaLat'],), s=300,
                         marker='v', color='', edgecolor=stationColor)
            axEM.text(dict['StaLon'], dict['StaLat'], '  ' + dict['Station'],
                      color=stationColor, va='top', family='monospace')
            for _i, ph in enumerate(SEISMIC_PHASES):
                if ph + 'res' in dict:
                    res_info = '\n' * (_i + 2) + '%+0.3fs' % dict[ph + 'res']
                    if ph + 'Pol' in dict:
                        res_info += '  %s' % dict[ph + 'Pol']
                    axEM.text(dict['StaLon'], dict['StaLat'], res_info,
                              va='top', family='monospace',
                              color=PHASE_COLORS[ph])
            if 'Mag' in dict:
                self.scatterMagIndices.append(i)
                self.scatterMagLon.append(dict['StaLon'])
                self.scatterMagLat.append(dict['StaLat'])
                label = '\n' * (_i + 3) + \
                        '  %0.2f (%s)' % (dict['Mag'], dict['MagChannel'])
                axEM.text(dict['StaLon'], dict['StaLat'], label, va='top',
                          family='monospace', color=PHASE_COLORS['Mag'])
        if len(self.scatterMagLon) > 0:
            self.scatterMag = axEM.scatter(self.scatterMagLon,
                    self.scatterMagLat, s=150, marker='v', color='',
                    edgecolor='black', picker=10)
                
        axEM.set_xlabel('Longitude')
        axEM.set_ylabel('Latitude')
        time = dO['Time']
        timestr = time.strftime("%Y-%m-%d  %H:%M:%S")
        timestr += ".%02d" % (time.microsecond / 1e4 + 0.5)
        axEM.set_title(timestr)
        #####XXX disabled because it plots the wrong info if the event was
        ##### fetched from seishub
        #####lines = open(PROGRAMS['3dloc']['files']['out']).readlines()
        #####infoEvent = lines[0].rstrip()
        #####infoPicks = ''
        #####for line in lines[1:]:
        #####    infoPicks += line
        #####axEM.text(0.02, 0.95, infoEvent, transform = axEM.transAxes,
        #####                  fontsize = 12, verticalalignment = 'top',
        #####                  family = 'monospace')
        #####axEM.text(0.02, 0.90, infoPicks, transform = axEM.transAxes,
        #####                  fontsize = 10, verticalalignment = 'top',
        #####                  family = 'monospace')
        # save id to disconnect when switching back to stream dislay
        self.eventMapPickEvent = self.canv.mpl_connect('pick_event',
                                                       self.selectMagnitudes)
        try:
            self.scatterMag.set_facecolors(self.eventMapColors)
        except:
            pass

        # make hexbin scatter plot, if located with NLLoc
        # XXX no vital commands should come after this block, as we do not
        # handle exceptions!
        if dO.get('Program') == "NLLoc" and os.path.isfile(PROGRAMS['nlloc']['files']['scatter']):
            cmap = matplotlib.cm.gist_heat_r
            data = readNLLocScatter(PROGRAMS['nlloc']['files']['scatter'],
                                    self.widgets.qPlainTextEdit_stderr)
            axEM.hexbin(data[0], data[1], cmap=cmap, zorder=-1000)

            self.axEventMapInletXY = self.fig.add_axes([0.8, 0.8, 0.16, 0.16])
            axEMiXY = self.axEventMapInletXY
            self.axEventMapInletXZ = self.fig.add_axes([0.8, 0.73, 0.16, 0.06],
                    sharex=axEMiXY)
            self.axEventMapInletZY = self.fig.add_axes([0.73, 0.8, 0.06, 0.16],
                    sharey=axEMiXY)
            axEMiXZ = self.axEventMapInletXZ
            axEMiZY = self.axEventMapInletZY
            
            # z axis in km
            axEMiXY.hexbin(data[0], data[1], cmap=cmap)
            axEMiXZ.hexbin(data[0], data[2]/1000., cmap=cmap)
            axEMiZY.hexbin(data[2]/1000., data[1], cmap=cmap)

            axEMiXZ.invert_yaxis()
            axEMiZY.invert_xaxis()
            axEMiXY.axis("equal")
            
            formatter = FormatStrFormatter("%.3f")
            axEMiXY.xaxis.set_major_formatter(formatter)
            axEMiXY.yaxis.set_major_formatter(formatter)
            
            # only draw very few ticklabels in our tiny subaxes
            for ax in [axEMiXZ.xaxis, axEMiXZ.yaxis,
                       axEMiZY.xaxis, axEMiZY.yaxis]:
                ax.set_major_locator(MaxNLocator(nbins=3))
            
            # hide ticklabels on XY plot
            for ax in [axEMiXY.xaxis, axEMiXY.yaxis]:
                plt.setp(ax.get_ticklabels(), visible=False)

    def delEventMap(self):
        try:
            self.canv.mpl_disconnect(self.eventMapPickEvent)
        except AttributeError:
            pass
        if hasattr(self, "axEventMapInletXY"):
            self.fig.delaxes(self.axEventMapInletXY)
            del self.axEventMapInletXY
        if hasattr(self, "axEventMapInletXZ"):
            self.fig.delaxes(self.axEventMapInletXZ)
            del self.axEventMapInletXZ
        if hasattr(self, "axEventMapInletZY"):
            self.fig.delaxes(self.axEventMapInletZY)
            del self.axEventMapInletZY
        if hasattr(self, "axEventMap"):
            self.fig.delaxes(self.axEventMap)
            del self.axEventMap

    def selectMagnitudes(self, event):
        if event.artist != self.scatterMag:
            return
        i = self.scatterMagIndices[event.ind[0]]
        j = event.ind[0]
        dict = self.dicts[i]
        dict['MagUse'] = not dict['MagUse']
        if dict['MagUse']:
            self.eventMapColors[j] = (0.,  1.,  0.,  1.)
        else:
            self.eventMapColors[j] = (0.,  0.,  0.,  0.)
        self.scatterMag.set_facecolors(self.eventMapColors)
        self.updateNetworkMag()
        self.canv.draw()
    
    def clearDictionaries(self):
        print "Clearing previous data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle',
                       'pazZ', 'pazN', 'pazE']
        for dict in self.dicts:
            for key in dict.keys():
                if not key in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        # XXX delegate all resetting to methods like self.clearOriginMagnitudeDictionaries() !!!
        # XXX but caution this can easily change behavior of obspyck!!
        self.dictOrigin = {}
        self.dictMagnitude = {}
        #self.clearFocmecDictionary()
        self.dictEvent = {}

    def clearOriginMagnitudeDictionaries(self):
        print "Clearing previous origin and magnitude data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle', 'pazZ', 'pazN',
                       'pazE', 'P', 'PErr1', 'PErr2', 'POnset', 'PPol',
                       'PWeight', 'S', 'SErr1', 'SErr2', 'SOnset', 'SPol',
                       'SWeight', 'Saxind',
                       #dont delete the manually picked maxima/minima
                       'MagMin1', 'MagMin1T', 'MagMax1', 'MagMax1T',
                       'MagMin2', 'MagMin2T', 'MagMax2', 'MagMax2T',]
        # we need to delete all station magnitude information from all dicts
        for dict in self.dicts:
            for key in dict.keys():
                if key not in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.dictEvent = {}
        #if 'xmlEventID' in self.dictEvent:
        #    del self.dictEvent['xmlEventID']


    def drawAllItems(self):
        keys_line = (phase_type + suffix \
                     for phase_type in SEISMIC_PHASES \
                     for suffix in ('', 'Err1', 'Err2', 'synth'))
        keys_label = (phase_type + suffix \
                      for phase_type in SEISMIC_PHASES \
                      for suffix in ('', 'synth'))
        for key in keys_line:
            self.drawLine(key)
        for key in keys_label:
            self.drawLabel(key)
        for key in ('MagMin1', 'MagMax1', 'MagMin2', 'MagMax2'):
            self.drawMagMarker(key)
    
    def delAllItems(self):
        keys_line = (phase_type + suffix \
                     for phase_type in SEISMIC_PHASES \
                     for suffix in ('', 'Err1', 'Err2', 'synth'))
        keys_label = (phase_type + suffix \
                      for phase_type in SEISMIC_PHASES \
                      for suffix in ('', 'synth'))
        for key in keys_line:
            self.delLine(key)
        for key in keys_label:
            self.delLabel(key)
        for key in ('MagMin1', 'MagMax1', 'MagMin2', 'MagMax2'):
            self.delMagMarker(key)

    def updateAllItems(self):
        self.delAllItems()
        self.drawAllItems()


def main():
    """ execute when the program starts """
    parser = argparse.ArgumentParser()
    for arg, kwargs in COMMANDLINE_OPTIONS:
        parser.add_argument(*arg, **kwargs)
    options = parser.parse_args()
    args = options.arguments
    #print options, args, options.database
    #return
    # For keybindings option, just print them and exit.
    if options.keybindings:
        for key, value in KEYS.iteritems():
            print "%s: \"%s\"" % (key, value)
        return
    #===
    # данные в любом случае загружаются из файлов
    files = []
    streams = []
    dicts = []
    # check wich options to use
    if options.datetime:
        print("Now we will search by datetime")
    elif options.directory:
        print("Now we will search by directory")
    elif options.iddir:
        print("Now we will search by idDir")
        # поиск в бд по коду idDir
        # соединяемся с базой данных
        conn, cursor = setup_db_connection()
        # выполнять запрос
        for value in args:
            QUERY = SELECT_CODES.replace("1", str(options.database))
            items = execute_query(cursor, QUERY, (value,)) or []
            for item in items:
                Dir, fname = item[1:]
                Dir = Dir[Dir.index(DATA_DIR):].replace("\\", "/")
                filename = os.path.join(Dir, fname)
                files += [filename]
                #
                print filename, os.path.exists(filename)
                # получить трассы из файлов Байкал
                traces = get_traces_from_baikal_file(filename)
                if traces is None:
                    raise BaseException("Could not load data from %s!" % filename)
                    #continue
                # создать поток (stream)
                st = Stream(traces=traces)
                # словари с временами вступлений по событию
                dic = {}
                trZ = st.select(component="Z")[0]
                dic['MagUse'] = True
                sta = trZ.stats.station.strip()
                dic['Station'] = sta
                # получить времена вступления волн по коду idPrn
                QUERY2 = SELECT_WAVES.replace("1", str(options.database))
                waves = execute_query(cursor, QUERY2, (item[0],))
                # заполнить dic
                for wave in waves:
                    NameWave = wave[0][0].upper()
                    #if NameWave not in SEISMIC_PHASES:
                    #    SEISMIC_PHASES += [NameWave]
                    # сохранить время вступления как строку
                    dic[NameWave] = wave[1]
                # save them all
                dicts += [dic]
                streams += [st]
                #
    else:
        print("Dont know what to do!")
    #===
    # получили потоки с трассами,
    # установить глобальный T0 - наименьшее время начала файла среди потоков
    # и Т1 - аналогичный max
    T0, T1 = None, None
    for st in streams:
        d1 = st.traces[0].stats.starttime# время начала данного потока
        if T0 is None: T0 = d1
        else:
            if d1 < T0: T0 = d1# если это раньше нашего начала - заменить
        # max
        d2 = st.traces[0].stats.endtime# время конца данного потока
        if T1 is None: T1 = d2
        else:
            if d2 > T1: T1 = d2
    # рассчитать время волны в секундах вместо строки для всех словарей
    for dic in dicts:
        for k, v in dic.iteritems():
            if k in SEISMIC_PHASES:
                # перевести строку в секунды относительно T0
                # с поправкой на начальное смещение
                dic[k] = calc_seconds_from_T0(v, T0) - options.starttime_offset
    # ===
    # Create the GUI application
    qApp = QtGui.QApplication(sys.argv)
    obspyck = ObsPyck(T0, T1, dicts, streams, options, KEYS)
    #qApp.connect(qApp, QtCore.SIGNAL("aboutToQuit()"), obspyck.cleanup)
    os._exit(qApp.exec_())


if __name__ == "__main__":
    main()
